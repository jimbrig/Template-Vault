/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => TagFolderPlugin
});
var import_obsidian = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance3, create_fragment3, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment3 ? create_fragment3($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// store.ts
var treeRoot = writable();
var currentFile = writable("");
var maxDepth = writable(0);
var filterString = writable("");

// types.ts
var SUBTREE_MARK = "\u2192 ";
var SUBTREE_MARK_REGEX = /\/→ /g;

// TreeItemComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-1yv0nhj", ".lsl-f.svelte-1yv0nhj{flex-direction:row;display:flex;flex-grow:1}.tagfolder-titletagname.svelte-1yv0nhj{flex-grow:1}.tagfolder-quantity.svelte-1yv0nhj{width:3em;text-align:right}");
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function create_if_block_5(ctx) {
  let div2;
  let div1;
  let div0;
  let t_value = ctx[0].displayName + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t = text(t_value);
      attr(div0, "class", "nav-file-title-content");
      attr(div1, "class", "nav-file-title");
      toggle_class(div1, "is-active", ctx[6]);
      attr(div2, "class", "nav-file");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, t);
      if (!mounted) {
        dispose = [
          listen(div1, "click", ctx[19]),
          listen(div1, "mouseover", ctx[20]),
          listen(div1, "focus", focus_handler),
          listen(div1, "contextmenu", ctx[21])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].displayName + ""))
        set_data(t, t_value);
      if (dirty & 64) {
        toggle_class(div1, "is-active", ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let div5;
  let div4;
  let div0;
  let t0;
  let div3;
  let div1;
  let t1_value = ctx[0].tag + "";
  let t1;
  let t2;
  let div2;
  let t3_value = ctx[0].itemsCount + "";
  let t3;
  let t4;
  let t5;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[0].children && !ctx[5] && create_if_block_4(ctx);
  const if_block_creators = [create_if_block_1, create_if_block_3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[7] != 1 && ctx2[9] > ctx2[7])
      return 0;
    if (ctx2[0].descendants && !ctx2[5])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<svg viewBox="0 0 100 100" class="right-triangle" width="8" height="8"><path fill="currentColor" stroke="currentColor" d="M94.9,20.8c-1.4-2.5-4.1-4.1-7.1-4.1H12.2c-3,0-5.7,1.6-7.1,4.1c-1.3,2.4-1.2,5.2,0.2,7.6L43.1,88c1.5,2.3,4,3.7,6.9,3.7 s5.4-1.4,6.9-3.7l37.8-59.6C96.1,26,96.2,23.2,94.9,20.8L94.9,20.8z"></path></svg>`;
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div1, "class", "tagfolder-titletagname svelte-1yv0nhj");
      attr(div2, "class", "tagfolder-quantity svelte-1yv0nhj");
      attr(div3, "class", "nav-folder-title-content lsl-f svelte-1yv0nhj");
      attr(div4, "class", "nav-folder-title");
      toggle_class(div4, "is-active", ctx[0].children && ctx[5] && ctx[6]);
      attr(div5, "class", "nav-folder");
      toggle_class(div5, "is-collapsed", ctx[5]);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      append(div1, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, t3);
      append(div5, t4);
      if (if_block0)
        if_block0.m(div5, null);
      append(div5, t5);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div5, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div4, "click", ctx[17]),
          listen(div4, "contextmenu", ctx[18])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0].tag + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 1) && t3_value !== (t3_value = ctx2[0].itemsCount + ""))
        set_data(t3, t3_value);
      if (dirty & 97) {
        toggle_class(div4, "is-active", ctx2[0].children && ctx2[5] && ctx2[6]);
      }
      if (ctx2[0].children && !ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 33) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div5, t5);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div5, null);
        } else {
          if_block1 = null;
        }
      }
      if (dirty & 32) {
        toggle_class(div5, "is-collapsed", ctx2[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (if_block0)
        if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4(ctx) {
  let div;
  let current;
  let each_value_2 = ctx[0].children.filter(func);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 287) {
        each_value_2 = ctx2[0].children.filter(func);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_2(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[22],
      openfile: ctx[2],
      hoverPreview: ctx[1],
      expandFolder: ctx[3],
      showMenu: ctx[4],
      path: ctx[8]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty & 1)
        treeitemcomponent_changes.entry = ctx2[22];
      if (dirty & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  let current;
  let each_value_1 = ctx[0].descendants;
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 287) {
        each_value_1 = ctx2[0].descendants;
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0].allDescendants && !ctx[5] && create_if_block_2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0].allDescendants && !ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 33) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_each_block_1(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[22],
      openfile: ctx[2],
      hoverPreview: ctx[1],
      expandFolder: ctx[3],
      showMenu: ctx[4],
      path: ctx[8]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty & 1)
        treeitemcomponent_changes.entry = ctx2[22];
      if (dirty & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let div;
  let current;
  let each_value = ctx[0].allDescendants;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 287) {
        each_value = ctx2[0].allDescendants;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[22],
      openfile: ctx[2],
      expandFolder: ctx[3],
      hoverPreview: ctx[1],
      showMenu: ctx[4],
      path: ctx[8]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty & 1)
        treeitemcomponent_changes.entry = ctx2[22];
      if (dirty & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function fallback_block(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_if_block_5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 129)
      show_if = null;
    if (show_if == null)
      show_if = !!("tag" in ctx2[0] && (ctx2[9] <= ctx2[7] || ctx2[0].tag.startsWith(SUBTREE_MARK)));
    if (show_if)
      return 0;
    if ("path" in ctx2[0])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment(ctx) {
  let current;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  return {
    c() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[15], !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null), null);
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 255)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function getFilenames(entry) {
  if (entry.allDescendants == null) {
    return [];
  } else {
    const filenames = entry.allDescendants.map((e) => e.path);
    return Array.from(new Set([...filenames]));
  }
}
var func = (e) => "tag" in e;
var focus_handler = () => {
};
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { entry } = $$props;
  let { hoverPreview } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { showMenu } = $$props;
  let { path } = $$props;
  let collapsed = true;
  let isSelected = false;
  const currentPath = path + ("tag" in entry ? entry.tag + "/" : "");
  const currentDepth = path.replace(SUBTREE_MARK_REGEX, "###").split("/").length;
  let _maxDepth = 0;
  function toggleFolder(entry2) {
    if ("tag" in entry2) {
      expandFolder(entry2, collapsed);
      $$invalidate(5, collapsed = !collapsed);
    }
  }
  function openfileLocal(entry2) {
    if ("path" in entry2)
      openfile(entry2.path);
  }
  function handleContextMenu(e, path2, entry2) {
    showMenu(e, path2, entry2);
  }
  function handleMouseover(e, entry2) {
    if ("path" in entry2)
      hoverPreview(e, entry2.path);
  }
  currentFile.subscribe((path2) => {
    $$invalidate(6, isSelected = false);
    if ("tags" in entry && entry.path == path2) {
      $$invalidate(6, isSelected = true);
    }
    if ("tag" in entry && getFilenames(entry).contains(path2)) {
      $$invalidate(6, isSelected = true);
    }
  });
  maxDepth.subscribe((depth) => {
    $$invalidate(7, _maxDepth = depth);
    if (depth == 0) {
      $$invalidate(7, _maxDepth = currentDepth + 1);
    }
  });
  const click_handler = () => toggleFolder(entry);
  const contextmenu_handler = (e) => handleContextMenu(e, currentPath, entry);
  const click_handler_1 = () => openfileLocal(entry);
  const mouseover_handler = (e) => handleMouseover(e, entry);
  const contextmenu_handler_1 = (e) => handleContextMenu(e, currentPath, entry);
  $$self.$$set = ($$props2) => {
    if ("entry" in $$props2)
      $$invalidate(0, entry = $$props2.entry);
    if ("hoverPreview" in $$props2)
      $$invalidate(1, hoverPreview = $$props2.hoverPreview);
    if ("openfile" in $$props2)
      $$invalidate(2, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(3, expandFolder = $$props2.expandFolder);
    if ("showMenu" in $$props2)
      $$invalidate(4, showMenu = $$props2.showMenu);
    if ("path" in $$props2)
      $$invalidate(14, path = $$props2.path);
    if ("$$scope" in $$props2)
      $$invalidate(15, $$scope = $$props2.$$scope);
  };
  return [
    entry,
    hoverPreview,
    openfile,
    expandFolder,
    showMenu,
    collapsed,
    isSelected,
    _maxDepth,
    currentPath,
    currentDepth,
    toggleFolder,
    openfileLocal,
    handleContextMenu,
    handleMouseover,
    path,
    $$scope,
    slots,
    click_handler,
    contextmenu_handler,
    click_handler_1,
    mouseover_handler,
    contextmenu_handler_1
  ];
}
var TreeItemComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      entry: 0,
      hoverPreview: 1,
      openfile: 2,
      expandFolder: 3,
      showMenu: 4,
      path: 14
    }, add_css);
  }
};
var TreeItemComponent_default = TreeItemComponent;

// TagFolderViewComponent.svelte
function add_css2(target) {
  append_styles(target, "svelte-1lyxrts", ".nav-folder.svelte-1lyxrts{padding-bottom:64px}.nav-files-container.svelte-1lyxrts{height:100%}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div1;
  let input;
  let t;
  let div0;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Type to start search...");
      attr(div0, "class", "search-input-clear-button");
      attr(div0, "aria-label", "Clear search");
      set_style(div0, "display", "none");
      attr(div1, "class", "search-input-container");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      set_input_value(input, ctx[9]);
      append(div1, t);
      append(div1, div0);
      if (!mounted) {
        dispose = listen(input, "input", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 512 && input.value !== ctx2[9]) {
        set_input_value(input, ctx2[9]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block2(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent_default({
    props: {
      entry: ctx[14],
      hoverPreview: ctx[1],
      openfile: ctx[2],
      expandFolder: ctx[3],
      showMenu: ctx[5],
      path: "/"
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty & 1)
        treeitemcomponent_changes.entry = ctx2[14];
      if (dirty & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty & 32)
        treeitemcomponent_changes.showMenu = ctx2[5];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let div5;
  let div4;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  let div3;
  let t3;
  let div11;
  let t4;
  let div10;
  let div8;
  let div6;
  let t5;
  let div7;
  let t6;
  let t7;
  let t8;
  let div9;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[10] && create_if_block2(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<svg viewBox="0 0 100 100" class="document" width="20" height="20"><path fill="currentColor" stroke="currentColor" d="M14,4v92h72V29.2l-0.6-0.6l-24-24L60.8,4L14,4z M18,8h40v24h24v60H18L18,8z M62,10.9L79.1,28H62V10.9z"></path></svg>`;
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<svg viewBox="0 0 100 100" class="up-and-down-arrows" width="20" height="20"><path fill="currentColor" stroke="currentColor" d="M25.8,5.9c-0.1,0-0.2,0-0.3,0.1c-0.1,0-0.1,0-0.2,0.1c-0.1,0-0.1,0-0.2,0.1c-0.1,0.1-0.3,0.2-0.4,0.3 c-0.1,0.1-0.2,0.1-0.3,0.2c-0.1,0.1-0.2,0.2-0.3,0.3L8.6,22.6c-0.8,0.8-0.8,2.1,0,2.9c0.8,0.8,2.1,0.8,2.9,0L24,12.9V76 c0,0.7,0.4,1.4,1,1.8c0.6,0.4,1.4,0.4,2,0c0.6-0.4,1-1,1-1.8V12.9l12.6,12.6c0.8,0.8,2.1,0.8,2.9,0c0.8-0.8,0.8-2.1,0-2.9 L27.7,6.9c-0.1-0.2-0.3-0.4-0.6-0.6c-0.2-0.2-0.5-0.3-0.8-0.3C26.2,6,26,5.9,25.8,5.9L25.8,5.9z M74,6c-1.1,0-2,0.9-2,2s0.9,2,2,2 s2-0.9,2-2S75.1,6,74,6z M74,14c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S75.1,14,74,14z M73.8,21.9c-0.1,0-0.2,0-0.3,0.1 c-0.9,0.2-1.6,1-1.6,2v63.1L59.4,74.6c-0.5-0.5-1.2-0.7-1.9-0.6c-0.8,0.1-1.4,0.7-1.6,1.4c-0.2,0.7,0,1.5,0.6,2l15.8,15.7 c0,0.1,0.1,0.1,0.1,0.2l0.1,0.1c0,0,0.1,0.1,0.1,0.1c0,0,0,0,0.1,0c0.1,0.1,0.3,0.2,0.4,0.3c0,0,0,0,0.1,0c0,0,0.1,0,0.1,0.1 c0,0,0,0,0.1,0c0.1,0,0.1,0,0.2,0.1c0.2,0,0.4,0,0.6,0c0,0,0.1,0,0.1,0c0.2,0,0.3-0.1,0.5-0.2c0.3-0.1,0.5-0.3,0.7-0.6l15.9-15.8 c0.8-0.8,0.8-2.1,0-2.9c-0.8-0.8-2.1-0.8-2.9,0L76,87.1V24c0-0.6-0.2-1.1-0.6-1.5C75,22.1,74.4,21.9,73.8,21.9L73.8,21.9z M26,82 c-1.1,0-2,0.9-2,2c0,1.1,0.9,2,2,2c1.1,0,2-0.9,2-2C28,82.9,27.1,82,26,82z M26,90c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2 C28,90.9,27.1,90,26,90z"></path></svg>`;
      t1 = space();
      div2 = element("div");
      div2.innerHTML = `<svg viewBox="0 0 100 100" class="stacked-levels" width="20" height="20"><path fill="currentColor" stroke="currentColor" d="M12,4c-1.1,0-2,0.9-2,2v20c0,1.1,0.9,2,2,2h14v21.7c0,0.2,0,0.4,0,0.7V84c0,1.1,0.9,2,2,2h26v8c0,1.1,0.9,2,2,2h32 c1.1,0,2-0.9,2-2V74c0-1.1-0.9-2-2-2H56c-1.1,0-2,0.9-2,2v8H30V52h24v8c0,1.1,0.9,2,2,2h32c1.1,0,2-0.9,2-2V40c0-1.1-0.9-2-2-2 H56c-1.1,0-2,0.9-2,2v8H30V28h14c1.1,0,2-0.9,2-2V6c0-1.1-0.9-2-2-2L12,4z M14,8h28v16H28.3c-0.1,0-0.2,0-0.3,0 c-0.1,0-0.2,0-0.3,0H14L14,8z M58,42h28v16H58v-7.7c0-0.2,0-0.4,0-0.7V42z M58,76h28v16H58v-7.7c0-0.2,0-0.4,0-0.7V76z"></path></svg>`;
      t2 = space();
      div3 = element("div");
      div3.innerHTML = `<svg viewBox="0 0 100 100" class="search" width="20" height="20"><path fill="currentColor" stroke="currentColor" stroke-width="2" d="M42,6C23.2,6,8,21.2,8,40s15.2,34,34,34c7.4,0,14.3-2.4,19.9-6.4l26.3,26.3l5.6-5.6l-26-26.1c5.1-6,8.2-13.7,8.2-22.1 C76,21.2,60.8,6,42,6z M42,10c16.6,0,30,13.4,30,30S58.6,70,42,70S12,56.6,12,40S25.4,10,42,10z"></path></svg>`;
      t3 = space();
      div11 = element("div");
      if (if_block)
        if_block.c();
      t4 = space();
      div10 = element("div");
      div8 = element("div");
      div6 = element("div");
      t5 = space();
      div7 = element("div");
      t6 = text("Tags: ");
      t7 = text(ctx[4]);
      t8 = space();
      div9 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "nav-action-button");
      attr(div0, "aria-label", "New note");
      attr(div1, "class", "nav-action-button");
      attr(div1, "aria-label", "Change sort order");
      attr(div2, "class", "nav-action-button");
      attr(div2, "aria-label", "Expand limit");
      attr(div3, "class", "nav-action-button");
      attr(div3, "aria-label", "Search");
      attr(div4, "class", "nav-buttons-container tagfolder-buttons-container");
      attr(div5, "class", "nav-header");
      attr(div6, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div7, "class", "nav-folder-title-content");
      attr(div8, "class", "nav-folder-title");
      attr(div9, "class", "nav-folder-children");
      attr(div10, "class", "nav-folder mod-root svelte-1lyxrts");
      attr(div11, "class", "nav-files-container svelte-1lyxrts");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div4, t0);
      append(div4, div1);
      append(div4, t1);
      append(div4, div2);
      append(div4, t2);
      append(div4, div3);
      insert(target, t3, anchor);
      insert(target, div11, anchor);
      if (if_block)
        if_block.m(div11, null);
      append(div11, t4);
      append(div11, div10);
      append(div10, div8);
      append(div8, div6);
      append(div8, t5);
      append(div8, div7);
      append(div7, t6);
      append(div7, t7);
      append(div10, t8);
      append(div10, div9);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div9, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", function() {
            if (is_function(ctx[8]))
              ctx[8].apply(this, arguments);
          }),
          listen(div1, "click", function() {
            if (is_function(ctx[7]))
              ctx[7].apply(this, arguments);
          }),
          listen(div2, "click", function() {
            if (is_function(ctx[6]))
              ctx[6].apply(this, arguments);
          }),
          listen(div3, "click", ctx[11])
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[10]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block2(ctx);
          if_block.c();
          if_block.m(div11, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 16)
        set_data(t7, ctx[4]);
      if (dirty & 47) {
        each_value = ctx[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div9, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div11);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { items = [] } = $$props;
  let { hoverPreview } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { vaultname = "" } = $$props;
  let { showMenu } = $$props;
  let { showLevelSelect } = $$props;
  let { showOrder } = $$props;
  let { newNote } = $$props;
  let { setSearchString } = $$props;
  treeRoot.subscribe((root) => {
    var _a;
    $$invalidate(0, items = (_a = root === null || root === void 0 ? void 0 : root.children) !== null && _a !== void 0 ? _a : []);
  });
  let search = "";
  let showSearch = false;
  function toggleSearch() {
    $$invalidate(10, showSearch = !showSearch);
    if (!showSearch) {
      $$invalidate(9, search = "");
    }
  }
  function input_input_handler() {
    search = this.value;
    $$invalidate(9, search);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("hoverPreview" in $$props2)
      $$invalidate(1, hoverPreview = $$props2.hoverPreview);
    if ("openfile" in $$props2)
      $$invalidate(2, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(3, expandFolder = $$props2.expandFolder);
    if ("vaultname" in $$props2)
      $$invalidate(4, vaultname = $$props2.vaultname);
    if ("showMenu" in $$props2)
      $$invalidate(5, showMenu = $$props2.showMenu);
    if ("showLevelSelect" in $$props2)
      $$invalidate(6, showLevelSelect = $$props2.showLevelSelect);
    if ("showOrder" in $$props2)
      $$invalidate(7, showOrder = $$props2.showOrder);
    if ("newNote" in $$props2)
      $$invalidate(8, newNote = $$props2.newNote);
    if ("setSearchString" in $$props2)
      $$invalidate(12, setSearchString = $$props2.setSearchString);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4608) {
      $: {
        if (setSearchString != null) {
          setSearchString(search);
        }
      }
    }
  };
  return [
    items,
    hoverPreview,
    openfile,
    expandFolder,
    vaultname,
    showMenu,
    showLevelSelect,
    showOrder,
    newNote,
    search,
    showSearch,
    toggleSearch,
    setSearchString,
    input_input_handler
  ];
}
var TagFolderViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      items: 0,
      hoverPreview: 1,
      openfile: 2,
      expandFolder: 3,
      vaultname: 4,
      showMenu: 5,
      showLevelSelect: 6,
      showOrder: 7,
      newNote: 8,
      setSearchString: 12
    }, add_css2);
  }
};
var TagFolderViewComponent_default = TagFolderViewComponent;

// main.ts
var HideItemsType = {
  NONE: "Hide nothing",
  DEDICATED_INTERMIDIATES: "Only intermediates of nested tags",
  ALL_EXCEPT_BOTTOM: "All intermediates"
};
var DEFAULT_SETTINGS = {
  displayMethod: "NAME",
  alwaysOpen: false,
  ignoreDocTags: "",
  ignoreTags: "",
  hideOnRootTags: "",
  sortType: "DISPNAME_ASC",
  sortTypeTag: "NAME_ASC",
  expandLimit: 0,
  disableNestedTags: false,
  hideItems: "NONE",
  ignoreFolders: "",
  scanDelay: 250
};
var VIEW_TYPE_TAGFOLDER = "tagfolder-view";
var OrderKeyTag = {
  NAME: "File name",
  ITEMS: "Count of items"
};
var OrderDirection = {
  ASC: "Ascending",
  DESC: "Descending"
};
var OrderKeyItem = {
  DISPNAME: "Displaying name",
  NAME: "File name",
  MTIME: "Modified time",
  CTIME: "Created time",
  FULLPATH: "Fullpath of the file"
};
var lastSkipped = 0;
var doevents = () => {
  const n = performance.now();
  if (n - lastSkipped < 20) {
    return Promise.resolve();
  }
  return new Promise((res) => {
    window.requestAnimationFrame(() => {
      lastSkipped = performance.now();
      res();
    });
  });
};
var TagFolderView = class extends import_obsidian.ItemView {
  getIcon() {
    return "stacked-levels";
  }
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
  }
  newNote(evt) {
    this.app.commands.executeCommandById("file-explorer:new-file");
  }
  showOrder(evt) {
    const menu = new import_obsidian.Menu(this.app);
    menu.addItem((item) => {
      item.setTitle("Tags").setIcon("hashtag").onClick((evt2) => __async(this, null, function* () {
        const menu2 = new import_obsidian.Menu(this.app);
        for (const key in OrderKeyTag) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(OrderKeyTag[key] + " " + OrderDirection[direction]).onClick(() => __async(this, null, function* () {
                this.plugin.settings.sortTypeTag = newSetting;
                yield this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              }));
              if (newSetting == this.plugin.settings.sortTypeTag) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      }));
      return item;
    });
    menu.addItem((item) => {
      item.setTitle("Items").setIcon("document").onClick((evt2) => __async(this, null, function* () {
        const menu2 = new import_obsidian.Menu(this.app);
        for (const key in OrderKeyItem) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(OrderKeyItem[key] + " " + OrderDirection[direction]).onClick(() => __async(this, null, function* () {
                this.plugin.settings.sortType = newSetting;
                yield this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              }));
              if (newSetting == this.plugin.settings.sortType) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      }));
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showLevelSelect(evt) {
    const menu = new import_obsidian.Menu(this.app);
    const setLevel = (level) => __async(this, null, function* () {
      this.plugin.settings.expandLimit = level;
      yield this.plugin.saveSettings();
      maxDepth.set(level);
      this.plugin.setRoot(this.plugin.root);
    });
    for (const level of [2, 3, 4, 5]) {
      menu.addItem((item) => {
        item.setTitle(`Level ${level - 1}`).onClick(() => {
          setLevel(level);
        });
        if (this.plugin.settings.expandLimit == level)
          item.setIcon("checkmark");
        return item;
      });
    }
    menu.addItem((item) => {
      item.setTitle("No limit").onClick(() => {
        setLevel(0);
      });
      if (this.plugin.settings.expandLimit == 0)
        item.setIcon("checkmark");
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  getViewType() {
    return VIEW_TYPE_TAGFOLDER;
  }
  getDisplayText() {
    return "Tag Folder";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.component = new TagFolderViewComponent_default({
        target: this.contentEl,
        props: {
          openfile: this.plugin.focusFile,
          hoverPreview: this.plugin.hoverPreview,
          expandFolder: this.plugin.expandFolder,
          vaultname: this.app.vault.getName(),
          showMenu: this.showMenu,
          showLevelSelect: this.showLevelSelect,
          showOrder: this.showOrder,
          newNote: this.newNote,
          setSearchString: this.plugin.setSearchString
        }
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      this.component.$destroy();
    });
  }
  setTreeRoot(root) {
    treeRoot.set(root);
  }
  showMenu(evt, path, entry) {
    const x = path.replace(SUBTREE_MARK_REGEX, "###");
    const expandedTags = x.split("/").filter((e) => e.trim() != "").map((e) => e.replace(/###/g, "/")).map((e) => "#" + e).join(" ").trim();
    const menu = new import_obsidian.Menu(this.app);
    if (navigator && navigator.clipboard) {
      menu.addItem((item) => item.setTitle("Copy tags").setIcon("hashtag").onClick(() => __async(this, null, function* () {
        yield navigator.clipboard.writeText(expandedTags);
        new import_obsidian.Notice("Copied");
      })));
    }
    menu.showAtMouseEvent(evt);
  }
};
var rippleDirty = (entry) => {
  for (const child of entry.children) {
    if ("tag" in child) {
      if (rippleDirty(child)) {
        entry.descendants = null;
        entry.allDescendants = null;
        entry.descendantsMemo = null;
      }
    }
  }
  if (entry.descendants == null)
    return true;
};
var retriveAllDecendants = (entry) => {
  return ("tag" in entry ? entry.children.map((e) => "tag" in e ? [...e.descendants, ...retriveAllDecendants(e)] : [e]) : [entry]).flat();
};
var expandDecendants = (entry, hideItems) => {
  const ret = [];
  for (const v of entry.children) {
    if ("tag" in v) {
      if (v.descendants == null) {
        const w = expandDecendants(v, hideItems).filter((e) => !ret.contains(e));
        ret.push(...w);
      } else {
        const w = v.descendants.filter((e) => !ret.contains(e));
        ret.push(...w);
      }
    } else {
      if (!ret.contains(v))
        ret.push(v);
    }
  }
  const leafs = entry.descendantsMemo != null ? entry.descendantsMemo : entry.descendantsMemo = entry.children.map((e) => "tag" in e ? e.children.map((ee) => retriveAllDecendants(ee).flat()).flat() : []).flat();
  if (hideItems == "DEDICATED_INTERMIDIATES" && entry.isDedicatedTree || hideItems == "ALL_EXCEPT_BOTTOM") {
    entry.descendants = ret.filter((e) => !leafs.contains(e));
  } else {
    entry.descendants = ret;
  }
  entry.allDescendants = ret;
  entry.itemsCount = new Set([...ret, ...leafs]).size;
  return ret;
};
var expandTree = (node) => __async(void 0, null, function* () {
  const tree = node.children;
  const ancestor = [...node.ancestors, node.tag];
  const tags = Array.from(new Set(node.children.filter((e) => "tags" in e).map((e) => e.tags).map((e) => e.map((ee) => ee.toLocaleString())).flat()));
  for (const tag of tags) {
    if (ancestor.map((e) => e.toLocaleLowerCase()).contains(tag.toLocaleLowerCase()))
      continue;
    const newChildren = node.children.filter((e) => "tags" in e && e.tags.map((e2) => e2.toLocaleLowerCase()).contains(tag.toLocaleLowerCase()));
    if (tree.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tag.toLocaleLowerCase())) {
      continue;
    }
    const newLeaf = {
      tag,
      children: newChildren,
      ancestors: [...ancestor, tag],
      descendants: null,
      isDedicatedTree: false,
      itemsCount: newChildren.length,
      allDescendants: null
    };
    tree.push(newLeaf);
    yield splitTag(newLeaf);
  }
});
var splitTag = (entry) => __async(void 0, null, function* () {
  let modified = false;
  yield doevents();
  entry.children = entry.children.sort((a, b) => {
    if ("tag" in a && "tag" in b) {
      return a.tag.split("/").length - b.tag.split("/").length;
    } else {
      return 0;
    }
  });
  for (const curEntry of entry.children) {
    if ("tag" in curEntry) {
      modified = (yield splitTag(curEntry)) || modified;
      if (curEntry.tag.contains("/")) {
        const tempEntry = curEntry;
        entry.children.remove(tempEntry);
        const tagsArray = tempEntry.tag.split("/");
        const tagCar = tagsArray.shift();
        const tagCdr = SUBTREE_MARK + tagsArray.join("/");
        const parent = entry.children.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCar.toLocaleLowerCase());
        const tempChildren = tempEntry.children;
        if (!parent) {
          const xchild = {
            tag: tagCdr,
            children: [...tempChildren],
            ancestors: [
              ...tempEntry.ancestors,
              tempEntry.tag,
              tagCdr
            ],
            itemsCount: 0,
            descendants: null,
            allDescendants: null,
            isDedicatedTree: false
          };
          const x = {
            tag: tagCar,
            children: [xchild],
            ancestors: [...tempEntry.ancestors, tempEntry.tag],
            descendants: null,
            allDescendants: null,
            isDedicatedTree: true,
            itemsCount: 0
          };
          x.children = [xchild];
          entry.children.push(x);
          yield splitTag(entry);
          modified = true;
        } else {
          const oldIx = parent.children.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCdr.toLocaleLowerCase());
          if (oldIx != null) {
            oldIx.children.push(...tempChildren.filter((e) => !oldIx.children.contains(e)));
            yield splitTag(oldIx);
          } else {
            const x = {
              tag: tagCdr,
              children: [...tempChildren],
              ancestors: [
                ...tempEntry.ancestors,
                tempEntry.tag,
                tagCdr
              ],
              descendants: null,
              allDescendants: null,
              isDedicatedTree: false,
              itemsCount: 0
            };
            parent.children.push(x);
            if (!parent.isDedicatedTree)
              parent.isDedicatedTree = true;
            yield splitTag(parent);
          }
          modified = true;
        }
      }
    }
  }
  if (modified) {
    yield splitTag(entry);
  }
  return modified;
});
function getCompareMethodTags(settings) {
  const invert = settings.sortTypeTag.contains("_DESC") ? -1 : 1;
  switch (settings.sortTypeTag) {
    case "ITEMS_ASC":
    case "ITEMS_DESC":
      return (a, b) => (a.itemsCount - b.itemsCount) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b) => a.tag.localeCompare(b.tag) * invert;
    default:
      console.warn("Compare method (tags) corrupted");
      return (a, b) => a.tag.localeCompare(b.tag) * invert;
  }
}
function getCompareMethodItems(settings) {
  const invert = settings.sortType.contains("_DESC") ? -1 : 1;
  switch (settings.sortType) {
    case "DISPNAME_ASC":
    case "DISPNAME_DESC":
      return (a, b) => a.displayName.localeCompare(b.displayName) * invert;
    case "FULLPATH_ASC":
    case "FULLPATH_DESC":
      return (a, b) => a.path.localeCompare(b.path) * invert;
    case "MTIME_ASC":
    case "MTIME_DESC":
      return (a, b) => (a.mtime - b.mtime) * invert;
    case "CTIME_ASC":
    case "CTIME_DESC":
      return (a, b) => (a.ctime - b.ctime) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b) => a.filename.localeCompare(b.filename) * invert;
    default:
      console.warn("Compare method (items) corrupted");
      return (a, b) => a.displayName.localeCompare(b.displayName) * invert;
  }
}
var TagFolderPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.expandedFolders = ["root"];
    this.currentOpeningFile = "";
    this.searchString = "";
    this.focusFile = (path) => {
      const targetFile = this.app.vault.getFiles().find((f) => f.path === path);
      if (targetFile) {
        const leaf = this.app.workspace.getLeaf(false);
        leaf.openFile(targetFile);
      }
    };
    this.expandFolder = (entry, expanded) => __async(this, null, function* () {
      if ("tag" in entry) {
        const key = [...entry.ancestors, entry.tag].join("/");
        if (expanded) {
          this.expandedFolders = Array.from(new Set([...this.expandedFolders, key]));
          this.expandedFolders = this.expandedFolders.sort((a, b) => a.split("/").length - b.split("/").length);
        } else {
          this.expandedFolders = this.expandedFolders.filter((e) => e != key);
        }
        yield this.expandLastExpandedFolders(entry);
        this.setRoot(this.root);
      }
    });
    this.fileCaches = [];
    this.oldFileCache = "";
    this.lastTags = "";
    this.lastSettings = "";
    this.lastSearchString = "";
  }
  getView() {
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)) {
      const view = leaf.view;
      if (view instanceof TagFolderView) {
        return view;
      }
    }
    return null;
  }
  hoverPreview(e, path) {
    this.app.workspace.trigger("hover-link", {
      event: e,
      source: "file-explorer",
      hoverParent: this,
      targetEl: e.target,
      linktext: path
    });
  }
  setSearchString(search) {
    this.searchString = search;
    this.refreshAllTree(null);
  }
  expandLastExpandedFolders(entry) {
    return __async(this, null, function* () {
      if ("tag" in entry) {
        const key = [...entry.ancestors, entry.tag].join("/");
        if (this.expandedFolders.contains(key)) {
          yield expandTree(entry);
          yield splitTag(entry);
          for (const child of entry.children) {
            yield this.expandLastExpandedFolders(child);
          }
        }
      }
    });
  }
  getDisplayName(file) {
    if (this.settings.displayMethod == "NAME") {
      return file.basename;
    }
    const path = file.path.split("/");
    path.pop();
    const dpath = path.join("/");
    if (this.settings.displayMethod == "NAME : PATH") {
      return `${file.basename} : ${dpath}`;
    }
    if (this.settings.displayMethod == "PATH/NAME") {
      return `${dpath}/${file.basename}`;
    }
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.hoverPreview = this.hoverPreview.bind(this);
      this.sortChildren = this.sortChildren.bind(this);
      this.setSearchString = this.setSearchString.bind(this);
      this.loadFileInfo = (0, import_obsidian.debounce)(this.loadFileInfo.bind(this), this.settings.scanDelay, true);
      this.registerView(VIEW_TYPE_TAGFOLDER, (leaf) => new TagFolderView(leaf, this));
      this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
        if (this.settings.alwaysOpen) {
          this.activateView();
        }
      }));
      this.addCommand({
        id: "tagfolder-open",
        name: "Show Tag Folder",
        callback: () => {
          this.activateView();
        }
      });
      this.metadataCacheChanged = this.metadataCacheChanged.bind(this);
      this.watchWorkspaceOpen = this.watchWorkspaceOpen.bind(this);
      this.registerEvent(this.app.metadataCache.on("changed", this.metadataCacheChanged));
      this.refreshAllTree = this.refreshAllTree.bind(this);
      this.registerEvent(this.app.vault.on("rename", this.refreshAllTree));
      this.registerEvent(this.app.vault.on("delete", this.refreshAllTree));
      this.registerEvent(this.app.workspace.on("file-open", this.watchWorkspaceOpen));
      this.watchWorkspaceOpen(this.app.workspace.getActiveFile());
      this.addSettingTab(new TagFolderSettingTab(this.app, this));
      maxDepth.set(this.settings.expandLimit);
    });
  }
  watchWorkspaceOpen(file) {
    if (file) {
      this.currentOpeningFile = file.path;
    } else {
      this.currentOpeningFile = "";
    }
    currentFile.set(this.currentOpeningFile);
  }
  metadataCacheChanged(file) {
    this.loadFileInfo(file);
  }
  refreshAllTree(file) {
    this.loadFileInfo();
  }
  sortChildren(a, b) {
    if ("tag" in a && !("tag" in b)) {
      return -1;
    } else if (!("tag" in a) && "tag" in b) {
      return 1;
    } else {
      if ("tag" in a && "tag" in b) {
        return this.compareTags(a, b);
      } else if ("tags" in a && "tags" in b) {
        return this.compareItems(a, b);
      } else {
        return 0;
      }
    }
  }
  sortTree(entry) {
    entry.children = entry.children.sort(this.sortChildren);
    for (const child of entry.children) {
      if ("tag" in child) {
        this.sortTree(child);
      }
    }
    entry.descendants = entry.descendants.sort(this.sortChildren);
  }
  setRoot(root) {
    var _a;
    rippleDirty(root);
    expandDecendants(root, this.settings.hideItems);
    this.sortTree(root);
    this.root = root;
    (_a = this.getView()) == null ? void 0 : _a.setTreeRoot(root);
  }
  updateFileCaches(diff) {
    if (this.fileCaches.length == 0 || !diff) {
      const files = this.app.vault.getMarkdownFiles();
      this.fileCaches = files.map((fileEntry) => {
        return {
          file: fileEntry,
          metadata: this.app.metadataCache.getFileCache(fileEntry)
        };
      });
    } else {
      this.fileCaches = this.fileCaches.filter((fileCache) => fileCache.file.path != diff.path);
      this.fileCaches.push({
        file: diff,
        metadata: this.app.metadataCache.getFileCache(diff)
      });
    }
    const fileCacheDump = JSON.stringify(this.fileCaches.map((e) => {
      var _a, _b;
      return {
        path: e.file.path,
        tags: ((_b = (_a = e.metadata) == null ? void 0 : _a.tags) != null ? _b : []).map((e2) => e2.tag)
      };
    }));
    if (this.oldFileCache == fileCacheDump) {
      return false;
    } else {
      this.oldFileCache = fileCacheDump;
      return true;
    }
  }
  getItemsList() {
    return __async(this, null, function* () {
      var _a;
      const items = [];
      const ignoreDocTags = this.settings.ignoreDocTags.toLocaleLowerCase().replace(/\n| /g, "").split(",");
      const ignoreTags = this.settings.ignoreTags.toLocaleLowerCase().replace(/\n| /g, "").split(",");
      const ignoreFolders = this.settings.ignoreFolders.toLocaleLowerCase().replace(/\n/g, "").split(",").map((e) => e.trim()).filter((e) => !!e);
      const searchItems = this.searchString.toLocaleLowerCase().split("|").map((ee) => ee.split(" ").map((e) => e.trim()));
      for (const fileCache of this.fileCaches) {
        if (ignoreFolders.find((e) => e != "" && fileCache.file.path.toLocaleLowerCase().startsWith(e))) {
          continue;
        }
        yield doevents();
        const allTagsDocs = (_a = (0, import_obsidian.getAllTags)(fileCache.metadata)) != null ? _a : [];
        let allTags = allTagsDocs.map((e) => e.substring(1));
        if (this.settings.disableNestedTags) {
          allTags = allTags.map((e) => e.split("/")).flat();
        }
        if (allTags.length == 0) {
          allTags = ["_untagged"];
        }
        if (allTags.some((tag) => ignoreDocTags.contains(tag.toLocaleLowerCase()))) {
          continue;
        }
        const w = searchItems.map((searchItem) => {
          let bx = false;
          for (const search of searchItem) {
            if (search.startsWith("-")) {
              bx = bx || allTags.some((tag) => tag.toLocaleLowerCase().contains(search.substring(1)));
              if (bx)
                continue;
            } else {
              bx = bx || allTags.every((tag) => !tag.toLocaleLowerCase().contains(search));
              if (bx)
                continue;
            }
          }
          return bx;
        });
        if (w.every((e) => e))
          continue;
        allTags = allTags.filter((tag) => !ignoreTags.contains(tag.toLocaleLowerCase()));
        items.push({
          tags: allTags,
          path: fileCache.file.path,
          displayName: this.getDisplayName(fileCache.file),
          ancestors: [],
          mtime: fileCache.file.stat.mtime,
          ctime: fileCache.file.stat.ctime,
          filename: fileCache.file.basename
        });
      }
      return items;
    });
  }
  buildUpTree(items) {
    return __async(this, null, function* () {
      const root = {
        tag: "root",
        children: [...items],
        ancestors: [],
        descendants: null,
        allDescendants: null,
        itemsCount: 0,
        isDedicatedTree: false
      };
      yield expandTree(root);
      root.children = root.children.filter((e) => "tag" in e);
      yield splitTag(root);
      yield this.expandLastExpandedFolders(root);
      return root;
    });
  }
  loadFileInfo(diff) {
    this.loadFileInfoAsync(diff);
  }
  loadFileInfoAsync(diff) {
    return __async(this, null, function* () {
      if (this.getView() == null)
        return;
      const strSetting = JSON.stringify(this.settings);
      const isSettingChanged = strSetting != this.lastSettings;
      const isSearchStringModified = this.searchString != this.lastSearchString;
      if (isSettingChanged) {
        this.lastSettings = strSetting;
      }
      if (isSearchStringModified) {
        this.lastSearchString = this.searchString;
      }
      if (!this.updateFileCaches(diff) && !isSearchStringModified && !isSettingChanged) {
        return;
      }
      const items = yield this.getItemsList();
      const root = yield this.buildUpTree(items);
      this.setRoot(root);
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
  }
  activateView() {
    return __async(this, null, function* () {
      this.loadFileInfo();
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
      yield this.app.workspace.getLeftLeaf(false).setViewState({
        type: VIEW_TYPE_TAGFOLDER,
        active: true
      });
      this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)[0]);
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      this.compareItems = getCompareMethodItems(this.settings);
      this.compareTags = getCompareMethodTags(this.settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      this.compareItems = getCompareMethodItems(this.settings);
      this.compareTags = getCompareMethodTags(this.settings);
    });
  }
};
var TagFolderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  hide() {
    this.plugin.loadFileInfo();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Tag Folder." });
    new import_obsidian.Setting(containerEl).setName("Always Open").setDesc("Open Tag Folder when obsidian has been launched").addToggle((toggle) => toggle.setValue(this.plugin.settings.alwaysOpen).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.alwaysOpen = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Display method").setDesc("Filename display").addDropdown((dropdown) => dropdown.addOptions({
      "PATH/NAME": "PATH/NAME",
      NAME: "NAME",
      "NAME : PATH": "NAME : PATH"
    }).setValue(this.plugin.settings.displayMethod).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.displayMethod = value;
      this.plugin.loadFileInfo(null);
      yield this.plugin.saveSettings();
    })));
    const setOrderMethod = (key, order) => __async(this, null, function* () {
      const oldSetting = this.plugin.settings.sortType.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortType = `${key}_${order}`;
      yield this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    });
    const setOrderMethodTag = (key, order) => __async(this, null, function* () {
      const oldSetting = this.plugin.settings.sortTypeTag.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortTypeTag = `${key}_${order}`;
      yield this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    });
    new import_obsidian.Setting(containerEl).setName("Order method (Tags)").setDesc("how to order tags").addDropdown((dd) => {
      dd.addOptions(OrderKeyTag).setValue(this.plugin.settings.sortTypeTag.split("_")[0]).onChange((key) => setOrderMethodTag(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortTypeTag.split("_")[1]).onChange((order) => setOrderMethodTag(null, order));
    });
    new import_obsidian.Setting(containerEl).setName("Order method (Items)").setDesc("how to order items").addDropdown((dd) => {
      dd.addOptions(OrderKeyItem).setValue(this.plugin.settings.sortType.split("_")[0]).onChange((key) => setOrderMethod(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortType.split("_")[1]).onChange((order) => setOrderMethod(null, order));
    });
    new import_obsidian.Setting(containerEl).setName("Do not treat nested tags as dedicated levels").setDesc("Treat nested tags as normal tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableNestedTags).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.disableNestedTags = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Hide Items").setDesc("Hide items on the landing or nested tags").addDropdown((dd) => {
      dd.addOptions(HideItemsType).setValue(this.plugin.settings.hideItems).onChange((key) => __async(this, null, function* () {
        if (key == "NONE" || key == "DEDICATED_INTERMIDIATES" || key == "ALL_EXCEPT_BOTTOM") {
          this.plugin.settings.hideItems = key;
        }
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Ignore note Tag").setDesc("If the note has the tag listed below, the note would be treated as there was not.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreDocTags).setPlaceholder("test,test1,test2").onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ignoreDocTags = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Ignore Tag").setDesc("Tags in the list would be treated as there were not.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreTags).setPlaceholder("test,test1,test2").onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ignoreTags = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Ignore Folders").setDesc("Ignore documents in specific folders.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreFolders).setPlaceholder("template,list/standard_tags").onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ignoreFolders = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Tag scanning delay").setDesc("Sets the delay for reflecting metadata changes to the tag tree. (Plugin reload is required.)").addText((text2) => {
      text2 = text2.setValue(this.plugin.settings.scanDelay + "").onChange((value) => __async(this, null, function* () {
        const newDelay = Number.parseInt(value, 10);
        if (newDelay) {
          this.plugin.settings.scanDelay = newDelay;
          yield this.plugin.saveSettings();
        }
      }));
      text2.inputEl.setAttribute("type", "number");
      text2.inputEl.setAttribute("min", "250");
      return text2;
    });
  }
};
